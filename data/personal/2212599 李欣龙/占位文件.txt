Yii2 Migration 迁移系统工作原理详解
==========================================

一、Migration 表的核心作用
---------------------------

Yii2 的 migration 系统依赖一个特殊的表：`migration` 表来记录哪些迁移已经执行过。

这个表的结构：
```sql
CREATE TABLE `migration` (
  `version` varchar(180) NOT NULL PRIMARY KEY,  -- 迁移版本号（文件名）
  `apply_time` int(11) DEFAULT NULL              -- 执行时间戳
);
```

执行流程：
1. 当你运行 `php yii migrate` 时
2. Yii2 会读取 `migration` 表，获取已执行的版本列表
3. 扫描 `console/migrations/` 目录下的所有 migration 文件
4. 对比：如果文件存在但 `migration` 表中没有记录 → 执行 `safeUp()`
5. 执行成功后，将版本号写入 `migration` 表

关键点：Yii2 判断是否执行迁移，只看 `migration` 表中是否有记录，而不是检查数据库中是否已经有同名表！


二、为什么会出现"表已存在"错误？
--------------------------------

问题场景：
- 数据库中已经有表（比如通过 `install.sql` 手动创建）
- 但是 `migration` 表中没有对应的记录
- 当执行 `php yii migrate` 时，Yii2 认为这个迁移还没执行
- 于是尝试执行 `CREATE TABLE` → 报错"表已存在"

常见原因：
1. 手动执行了 `install.sql` 创建了表，但没有标记 migration
2. 从其他环境导入了数据库，表存在但 migration 表记录不完整
3. 删除了 `migration` 表但保留了业务表
4. `start.sh` 脚本只标记了部分表，没有标记全部


三、start.sh 脚本的逻辑
-----------------------

查看 `start.sh` 的 `init_yii2()` 函数：

```bash
# start.sh 只检查了 3 个表：
- member 表 → 只记录日志，没有 mark
- user 表 → mark 2 个 migration
- battle 表 → mark 1 个 migration

# 但实际上有 11+ 个 migration，会创建很多表：
- sensitive_word
- contact_message  
- story (可能已存在)
- 等等...
```

问题：
如果数据库中已经有其他表（如 `sensitive_word`、`contact_message`），但 `start.sh` 没有检查并标记，执行 `php yii migrate` 时会尝试再次创建，导致"表已存在"错误。


四、为什么"一会行一会不行"？
------------------------------

情况1：第一次执行
- 数据库是空的 → 所有 migration 正常执行 → ✅ 成功

情况2：第二次执行
- 表已经存在，但 `migration` 表可能被清空或部分记录丢失
- Yii2 认为迁移未执行，尝试重复创建 → ❌ 失败

情况3：手动执行了 install.sql
- 表已经创建，但 `migration` 表没有记录
- 执行 migration 时尝试重复创建 → ❌ 失败

情况4：部分表存在
- 某些表已存在（如通过 install.sql），某些不存在
- 已存在的表会报错，不存在的表正常创建 → ⚠️ 部分成功


五、正确的解决方案
-------------------

方案A：在每个 migration 中加入存在性检查（推荐）
-------------------------------------------
```php
public function safeUp() {
    // 检查表是否已存在
    if ($this->db->schema->getTableSchema('{{%table_name}}', true) !== null) {
        echo "表已存在，跳过\n";
        return true;  // 直接返回，不报错
    }
    // 正常创建表...
    $this->createTable('{{%table_name}}', [...]);
}
```

优点：
- 即使表已存在也不会报错
- 可以安全地重复执行
- 适合生产环境

我们已经修改了以下 migration 文件：
- m251220_110000_create_sensitive_word_table.php
- m251220_110000_insert_member_data.php
- m251220_120000_remove_event_date_location_from_story_table.php
- m251220_130000_create_contact_message_table.php


方案B：改进 start.sh，自动检查所有表并标记
-------------------------------------------
在 start.sh 中检查所有可能存在的表，并标记对应的 migration。

缺点：
- 需要维护表名和 migration 的对应关系
- 如果新增 migration，需要同步更新脚本


方案C：确保数据库初始状态一致
--------------------------------
选择一种方式并保持一致：
- 要么完全空数据库 + 执行所有 migration
- 要么完全使用 install.sql + 手动标记所有 migration


六、总结
--------

1. Migration 系统依赖 `migration` 表记录版本，不依赖数据库中是否有同名表

2. start.sh 不需要数据库完全为空，但需要：
   - 所有已存在的表都要在 migration 中加入存在性检查，或
   - 手动标记所有对应的 migration 为已执行

3. 最佳实践：
   - 每个 `createTable` 的 migration 都加入存在性检查
   - 这样即使表已存在也不会报错
   - 可以安全地重复执行 migration

4. 这就是为什么我们修改了那些 migration 文件，加入存在性检查后就能正常运行了


七、实际操作建议
----------------

如果遇到"表已存在"错误：

1. 快速解决：手动标记该 migration 为已执行
   ```bash
   php yii migrate/mark m251220_110000_create_sensitive_word_table --interactive=0
   ```

2. 根本解决：修改 migration 文件，加入存在性检查
   ```php
   if ($this->db->schema->getTableSchema('{{%table_name}}', true) !== null) {
       return true;
   }
   ```

3. 预防措施：所有新建的 migration 都加入存在性检查，避免未来再次出现同样问题
